
// Servicio de API para comunicaci√≥n con el BFF seg√∫n ANEXO B

import axios from 'axios';
import { Platform } from 'react-native';
import { 
  PreLoginResponse, 
  LoginRequest, 
  LoginResponse, 
  Product, 
  ProductListItem,
  Order,
  Sucursal,
  Warehouse,
  AuthTokens 
} from '../types';

// Configuraci√≥n din√°mica de URL basada en el entorno
let BASE_URL = '';

// Definimos URLs para diferentes entornos
const SERVER_URLS = {
  webDev: 'http://localhost:3001/api',           // Desarrollo web local con proxy
  mobileDev: 'http://localhost:3000/api',        // Desarrollo en dispositivo m√≥vil
  production: 'https://bff.erp-api.com/api'      // Producci√≥n (ejemplo)
};

// Seleccionamos la URL base seg√∫n la plataforma
if (Platform.OS === 'web') {
  // Para desarrollo web siempre usamos el proxy local
  BASE_URL = SERVER_URLS.webDev;
  console.log('API configurada para desarrollo web con proxy:', BASE_URL);
} else {
  // Para dispositivos m√≥viles usamos la conexi√≥n directa al BFF
  // En producci√≥n, esto cambiar√≠a a SERVER_URLS.production
  BASE_URL = SERVER_URLS.mobileDev;
  console.log('API configurada para dispositivo m√≥vil:', BASE_URL);
}

// Configuraci√≥n de interceptores para depuraci√≥n
axios.interceptors.request.use(
  config => {
    console.log(`üì§ Enviando ${config.method?.toUpperCase()} a ${config.url}`);
    return config;
  },
  error => {
    console.error('‚ùå Error en solicitud:', error.message);
    return Promise.reject(error);
  }
);

axios.interceptors.response.use(
  response => {
    console.log(`üì• Respuesta de ${response.config.url}: ${response.status}`);
    return response;
  },
  error => {
    if (error.response) {
      console.error(`‚ùå Error ${error.response.status} de ${error.config?.url}`);
    } else {
      console.error('‚ùå Error de red:', error.message);
    }
    return Promise.reject(error);
  }
);

// Interceptor b√°sico para errores de red
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.message === 'Network Error') {
      console.error('Error de red detectado. Comprueba la conexi√≥n al servidor.');
    }
    return Promise.reject(error);
  }
);

class ApiService {
  private accessToken: string | null = null;

  setAccessToken(token: string) {
    this.accessToken = token;
  }

  private getAuthHeaders() {
    return this.accessToken ? {
      'Authorization': `Bearer ${this.accessToken}`,
      'Content-Type': 'application/json',
    } : {
      'Content-Type': 'application/json',
    };
  }

  // AUTH ENDPOINTS

  async preLogin(email: string): Promise<PreLoginResponse> {
    // Para pruebas, podemos usar un usuario de prueba
    if (email === 'test@example.com') {
      console.log('Usando credenciales de prueba para preLogin');
      // Crear una respuesta de prueba que coincida con PreLoginResponse
      return { 
        customer: {
          id: '1',
          code: 'TEST001',
          name: 'Usuario de Prueba',
          address: 'Direcci√≥n de prueba',
          phone: '1234567890',
          email: 'test@example.com',
          customerTypeId: '1',
          isActive: true
        },
        message: 'Usuario de prueba validado'
      };
    }
    
    try {
      console.log(`Enviando solicitud preLogin a: ${BASE_URL}/auth/mobile/pre-login`);
      
      // La solicitud real al servidor para usuarios de la base de datos
      const response = await axios.post(`${BASE_URL}/auth/mobile/pre-login`, 
        { email }, 
        { headers: { 'Content-Type': 'application/json' } }
      );
      
      console.log('Respuesta preLogin recibida:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('Error en preLogin:', error.response?.data || error.message);
      throw {
        message: error.response?.data?.message || 'Error en pre-login',
        status: error.response?.status || 500,
      };
    }
  }

  async login(data: LoginRequest): Promise<LoginResponse> {
    // Para pruebas, podemos usar un usuario de prueba
    if (data.email === 'test@example.com' && data.password === 'password') {
      console.log('Usando credenciales de prueba para login');
      return {
        tokens: {
          accessToken: 'test-access-token',
          refreshToken: 'test-refresh-token'
        },
        customer: {
          id: '1',
          code: 'TEST001',
          name: 'Usuario de Prueba',
          address: 'Direcci√≥n de prueba',
          phone: '1234567890',
          email: 'test@example.com',
          customerTypeId: '1',
          isActive: true
        },
        sucursal: {
          id: data.sucursalId || '1',
          name: 'Sucursal Prueba',
          code: 'SUC001',
          address: 'Direcci√≥n de sucursal de prueba'
        },
        warehouse: {
          id: data.almacenId || '1',
          name: 'Almac√©n Prueba',
          code: 'ALM001',
          address: 'Direcci√≥n de almac√©n de prueba',
          sucursalId: data.sucursalId || '1'
        }
      };
    }
    
    try {
      console.log(`Enviando solicitud login a: ${BASE_URL}/auth/mobile/login`);
      console.log('Datos de login:', JSON.stringify(data));
      
      const response = await axios.post(`${BASE_URL}/auth/mobile/login`, data, {
        headers: { 'Content-Type': 'application/json' }
      });
      
      console.log('Login exitoso:', response.data);
      return response.data;
    } catch (error: any) {
      console.error('Error en login:', error.response?.data || error.message);
      throw {
        message: error.response?.data?.message || 'Error en login',
        status: error.response?.status || 500,
      };
    }
  }

  async refreshToken(refreshToken: string): Promise<AuthTokens> {
    try {
      console.log(`Enviando solicitud refreshToken a: ${BASE_URL}/auth/mobile/refresh`);
      const response = await axios.post(`${BASE_URL}/auth/mobile/refresh`, {
        refreshToken,
      }, {
        headers: { 'Content-Type': 'application/json' }
      });
      console.log('Token refrescado exitosamente');
      return response.data;
    } catch (error: any) {
      console.error('Error al refrescar token:', error.response?.data || error.message);
      throw {
        message: error.response?.data?.message || 'Error al refrescar token',
        status: error.response?.status || 500,
      };
    }
  }

  // SUCURSALES Y ALMACENES

  async getSucursales(): Promise<Sucursal[]> {
    try {
      const response = await axios.get(`${BASE_URL}/api/sucursales`, {
        headers: this.getAuthHeaders(),
      });
      return response.data;
    } catch (error: any) {
      throw {
        message: error.response?.data?.message || 'Error obteniendo sucursales',
        status: error.response?.status || 500,
      };
    }
  }

  async getAlmacenes(sucursalId: string): Promise<Warehouse[]> {
    try {
      const response = await axios.get(`${BASE_URL}/api/almacenes?sucursalId=${sucursalId}`, {
        headers: this.getAuthHeaders(),
      });
      return response.data;
    } catch (error: any) {
      throw {
        message: error.response?.data?.message || 'Error obteniendo almacenes',
        status: error.response?.status || 500,
      };
    }
  }

  // PRODUCTOS

  async getProducts(page = 1, limit = 20, categoryId?: string, search?: string): Promise<{
    products: ProductListItem[];
    totalCount: number;
    hasMore: boolean;
  }> {
    try {
      const params = new URLSearchParams({
        page: page.toString(),
        limit: limit.toString(),
      });
      
      if (categoryId) params.append('categoryId', categoryId);
      if (search) params.append('search', search);

      const response = await axios.get(`${BASE_URL}/api/products?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });
      return response.data;
    } catch (error: any) {
      throw {
        message: error.response?.data?.message || 'Error obteniendo productos',
        status: error.response?.status || 500,
      };
    }
  }

  async getProductById(id: string): Promise<Product> {
    try {
      const response = await axios.get(`${BASE_URL}/api/products/${id}`, {
        headers: this.getAuthHeaders(),
      });
      return response.data;
    } catch (error: any) {
      throw {
        message: error.response?.data?.message || 'Error obteniendo producto',
        status: error.response?.status || 500,
      };
    }
  }

  // PEDIDOS

  async getOrders(page = 1, limit = 20, status?: string, startDate?: string, endDate?: string): Promise<{
    orders: Order[];
    totalCount: number;
    hasMore: boolean;
  }> {
    try {
      const params = new URLSearchParams({
        page: page.toString(),
        limit: limit.toString(),
      });
      
      if (status) params.append('status', status);
      if (startDate) params.append('startDate', startDate);
      if (endDate) params.append('endDate', endDate);

      const response = await axios.get(`${BASE_URL}/api/orders?${params.toString()}`, {
        headers: this.getAuthHeaders(),
      });
      return response.data;
    } catch (error: any) {
      throw {
        message: error.response?.data?.message || 'Error obteniendo pedidos',
        status: error.response?.status || 500,
      };
    }
  }

  async createOrder(orderData: {
    items: Array<{
      productId: string;
      quantity: number;
    }>;
  }): Promise<Order> {
    try {
      const response = await axios.post(`${BASE_URL}/api/orders`, orderData, {
        headers: this.getAuthHeaders(),
      });
      return response.data;
    } catch (error: any) {
      throw {
        message: error.response?.data?.message || 'Error creando pedido',
        status: error.response?.status || 500,
      };
    }
  }

  // FAVORITOS

  async getFavorites(): Promise<ProductListItem[]> {
    try {
      const response = await axios.get(`${BASE_URL}/api/favorites`, {
        headers: this.getAuthHeaders(),
      });
      return response.data;
    } catch (error: any) {
      throw {
        message: error.response?.data?.message || 'Error obteniendo favoritos',
        status: error.response?.status || 500,
      };
    }
  }

  async addToFavorites(productId: string): Promise<void> {
    try {
      await axios.post(`${BASE_URL}/api/favorites/${productId}`, {}, {
        headers: this.getAuthHeaders(),
      });
    } catch (error: any) {
      throw {
        message: error.response?.data?.message || 'Error agregando a favoritos',
        status: error.response?.status || 500,
      };
    }
  }

  async removeFromFavorites(productId: string): Promise<void> {
    try {
      await axios.delete(`${BASE_URL}/api/favorites/${productId}`, {
        headers: this.getAuthHeaders(),
      });
    } catch (error: any) {
      throw {
        message: error.response?.data?.message || 'Error removiendo de favoritos',
        status: error.response?.status || 500,
      };
    }
  }
}

export const apiService = new ApiService();
